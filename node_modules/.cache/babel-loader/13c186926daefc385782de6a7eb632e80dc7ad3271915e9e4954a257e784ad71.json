{"ast":null,"code":"'use strict';\n\nvar isNative = /\\.node$/;\nfunction forEach(obj, callback) {\n  for (var key in obj) {\n    if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n      continue;\n    }\n    callback(key);\n  }\n}\nfunction assign(target, source) {\n  forEach(source, function (key) {\n    target[key] = source[key];\n  });\n  return target;\n}\nfunction clearCache(requireCache) {\n  forEach(requireCache, function (resolvedPath) {\n    if (!isNative.test(resolvedPath)) {\n      delete requireCache[resolvedPath];\n    }\n  });\n}\nmodule.exports = function (requireCache, callback, callbackForModulesToKeep, module) {\n  var originalCache = assign({}, requireCache);\n  clearCache(requireCache);\n  if (callbackForModulesToKeep) {\n    var originalModuleChildren = module.children ? module.children.slice() : false; // Creates a shallow copy of module.children\n\n    callbackForModulesToKeep();\n\n    // Lists the cache entries made by callbackForModulesToKeep()\n    var modulesToKeep = [];\n    forEach(requireCache, function (key) {\n      modulesToKeep.push(key);\n    });\n\n    // Discards the modules required in callbackForModulesToKeep()\n    clearCache(requireCache);\n    if (module.children) {\n      // Only true for node.js\n      module.children = originalModuleChildren; // Removes last references to modules required in callbackForModulesToKeep() -> No memory leak\n    }\n\n    // Takes the cache entries of the original cache in case the modules where required before\n    for (var i = 0; i < modulesToKeep.length; i += 1) {\n      if (originalCache[modulesToKeep[i]]) {\n        requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];\n      }\n    }\n  }\n  var freshModule = callback();\n  var stealthCache = callbackForModulesToKeep ? assign({}, requireCache) : false;\n  clearCache(requireCache);\n  if (callbackForModulesToKeep) {\n    // In case modules to keep were required inside the stealthy require for the first time, copy them to the restored cache\n    for (var k = 0; k < modulesToKeep.length; k += 1) {\n      if (stealthCache[modulesToKeep[k]]) {\n        requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];\n      }\n    }\n  }\n  assign(requireCache, originalCache);\n  return freshModule;\n};","map":{"version":3,"names":["isNative","forEach","obj","callback","key","Object","prototype","hasOwnProperty","call","assign","target","source","clearCache","requireCache","resolvedPath","test","module","exports","callbackForModulesToKeep","originalCache","originalModuleChildren","children","slice","modulesToKeep","push","i","length","freshModule","stealthCache","k"],"sources":["/Users/rajnish/Desktop/INTERN/Homeoz HealthCare/Task 3 FrontEnd Development/client/node_modules/stealthy-require/lib/index.js"],"sourcesContent":["'use strict';\n\nvar isNative = /\\.node$/;\n\nfunction forEach(obj, callback) {\n    for ( var key in obj ) {\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n            continue;\n        }\n        callback(key);\n    }\n}\n\nfunction assign(target, source) {\n    forEach(source, function (key) {\n        target[key] = source[key];\n    });\n    return target;\n}\n\nfunction clearCache(requireCache) {\n    forEach(requireCache, function (resolvedPath) {\n        if (!isNative.test(resolvedPath)) {\n            delete requireCache[resolvedPath];\n        }\n    });\n}\n\nmodule.exports = function (requireCache, callback, callbackForModulesToKeep, module) {\n\n    var originalCache = assign({}, requireCache);\n    clearCache(requireCache);\n\n    if (callbackForModulesToKeep) {\n\n        var originalModuleChildren = module.children ? module.children.slice() : false; // Creates a shallow copy of module.children\n\n        callbackForModulesToKeep();\n\n        // Lists the cache entries made by callbackForModulesToKeep()\n        var modulesToKeep = [];\n        forEach(requireCache, function (key) {\n            modulesToKeep.push(key);\n        });\n\n        // Discards the modules required in callbackForModulesToKeep()\n        clearCache(requireCache);\n\n        if (module.children) { // Only true for node.js\n            module.children = originalModuleChildren; // Removes last references to modules required in callbackForModulesToKeep() -> No memory leak\n        }\n\n        // Takes the cache entries of the original cache in case the modules where required before\n        for ( var i = 0; i < modulesToKeep.length; i+=1 ) {\n            if (originalCache[modulesToKeep[i]]) {\n                requireCache[modulesToKeep[i]] = originalCache[modulesToKeep[i]];\n            }\n        }\n\n    }\n\n    var freshModule = callback();\n\n    var stealthCache = callbackForModulesToKeep ? assign({}, requireCache) : false;\n\n    clearCache(requireCache);\n\n    if (callbackForModulesToKeep) {\n        // In case modules to keep were required inside the stealthy require for the first time, copy them to the restored cache\n        for ( var k = 0; k < modulesToKeep.length; k+=1 ) {\n            if (stealthCache[modulesToKeep[k]]) {\n                requireCache[modulesToKeep[k]] = stealthCache[modulesToKeep[k]];\n            }\n        }\n    }\n\n    assign(requireCache, originalCache);\n\n    return freshModule;\n\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,QAAQ,GAAG,SAAS;AAExB,SAASC,OAAOA,CAACC,GAAG,EAAEC,QAAQ,EAAE;EAC5B,KAAM,IAAIC,GAAG,IAAIF,GAAG,EAAG;IACnB,IAAI,CAACG,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACN,GAAG,EAAEE,GAAG,CAAC,EAAE;MACjD;IACJ;IACAD,QAAQ,CAACC,GAAG,CAAC;EACjB;AACJ;AAEA,SAASK,MAAMA,CAACC,MAAM,EAAEC,MAAM,EAAE;EAC5BV,OAAO,CAACU,MAAM,EAAE,UAAUP,GAAG,EAAE;IAC3BM,MAAM,CAACN,GAAG,CAAC,GAAGO,MAAM,CAACP,GAAG,CAAC;EAC7B,CAAC,CAAC;EACF,OAAOM,MAAM;AACjB;AAEA,SAASE,UAAUA,CAACC,YAAY,EAAE;EAC9BZ,OAAO,CAACY,YAAY,EAAE,UAAUC,YAAY,EAAE;IAC1C,IAAI,CAACd,QAAQ,CAACe,IAAI,CAACD,YAAY,CAAC,EAAE;MAC9B,OAAOD,YAAY,CAACC,YAAY,CAAC;IACrC;EACJ,CAAC,CAAC;AACN;AAEAE,MAAM,CAACC,OAAO,GAAG,UAAUJ,YAAY,EAAEV,QAAQ,EAAEe,wBAAwB,EAAEF,MAAM,EAAE;EAEjF,IAAIG,aAAa,GAAGV,MAAM,CAAC,CAAC,CAAC,EAAEI,YAAY,CAAC;EAC5CD,UAAU,CAACC,YAAY,CAAC;EAExB,IAAIK,wBAAwB,EAAE;IAE1B,IAAIE,sBAAsB,GAAGJ,MAAM,CAACK,QAAQ,GAAGL,MAAM,CAACK,QAAQ,CAACC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;;IAEhFJ,wBAAwB,CAAC,CAAC;;IAE1B;IACA,IAAIK,aAAa,GAAG,EAAE;IACtBtB,OAAO,CAACY,YAAY,EAAE,UAAUT,GAAG,EAAE;MACjCmB,aAAa,CAACC,IAAI,CAACpB,GAAG,CAAC;IAC3B,CAAC,CAAC;;IAEF;IACAQ,UAAU,CAACC,YAAY,CAAC;IAExB,IAAIG,MAAM,CAACK,QAAQ,EAAE;MAAE;MACnBL,MAAM,CAACK,QAAQ,GAAGD,sBAAsB,CAAC,CAAC;IAC9C;;IAEA;IACA,KAAM,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,aAAa,CAACG,MAAM,EAAED,CAAC,IAAE,CAAC,EAAG;MAC9C,IAAIN,aAAa,CAACI,aAAa,CAACE,CAAC,CAAC,CAAC,EAAE;QACjCZ,YAAY,CAACU,aAAa,CAACE,CAAC,CAAC,CAAC,GAAGN,aAAa,CAACI,aAAa,CAACE,CAAC,CAAC,CAAC;MACpE;IACJ;EAEJ;EAEA,IAAIE,WAAW,GAAGxB,QAAQ,CAAC,CAAC;EAE5B,IAAIyB,YAAY,GAAGV,wBAAwB,GAAGT,MAAM,CAAC,CAAC,CAAC,EAAEI,YAAY,CAAC,GAAG,KAAK;EAE9ED,UAAU,CAACC,YAAY,CAAC;EAExB,IAAIK,wBAAwB,EAAE;IAC1B;IACA,KAAM,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,aAAa,CAACG,MAAM,EAAEG,CAAC,IAAE,CAAC,EAAG;MAC9C,IAAID,YAAY,CAACL,aAAa,CAACM,CAAC,CAAC,CAAC,EAAE;QAChChB,YAAY,CAACU,aAAa,CAACM,CAAC,CAAC,CAAC,GAAGD,YAAY,CAACL,aAAa,CAACM,CAAC,CAAC,CAAC;MACnE;IACJ;EACJ;EAEApB,MAAM,CAACI,YAAY,EAAEM,aAAa,CAAC;EAEnC,OAAOQ,WAAW;AAEtB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}